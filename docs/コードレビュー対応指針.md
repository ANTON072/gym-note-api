# コードレビュー対応指針

## 概要

このドキュメントは、Copilotからのコードレビュー指摘事項をまとめ、今後のコード生成時に同様の問題を予防するためのガイドラインを提供します。

## セキュリティとバリデーション

### 1. モデルバリデーションの必須実装

**指摘事項**: Userモデルでバリデーションが不足していた

**対応指針**:
```ruby
class User < ApplicationRecord
  # 必須フィールドのバリデーション
  validates :firebase_uid, presence: true, uniqueness: true
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :name, presence: true
  
  # その他の適切なバリデーションを追加
  # validates :phone, format: { with: /\A\d{10,11}\z/ }, allow_blank: true
end
```

**ルール**:
- 全てのモデルで必須フィールドに `presence: true` を設定
- 一意制約が必要なフィールドに `uniqueness: true` を設定
- メールフィールドには `URI::MailTo::EMAIL_REGEXP` を使用
- 外部キー（firebase_uid等）には適切な制約を設定

### 2. 外部データの安全な処理

**指摘事項**: Firebase payloadを直接`update!`/`create!`で使用していた

**対応指針**:
```ruby
# ❌ 危険な実装
def update_user_from_payload(user, payload)
  user.update!(
    email: payload["email"],           # 直接使用は危険
    name: payload["name"],
    image_url: payload["picture"]
  )
end

# ✅ 安全な実装
def update_user_from_payload(user, payload)
  user_attributes = build_safe_attributes(payload)
  user.update!(user_attributes)
end

private

def build_safe_attributes(payload)
  {
    email: sanitize_email(payload["email"]),
    name: sanitize_name(payload["name"]),
    image_url: sanitize_url(payload["picture"])
  }
end

def sanitize_email(email)
  return nil if email.blank?
  email.to_s.strip.downcase
end

def sanitize_name(name)
  return nil if name.blank?
  name.to_s.strip
end

def sanitize_url(url)
  return nil if url.blank?
  clean_url = url.to_s.strip
  clean_url.match?(/\Ahttps?:\/\/.+/) ? clean_url : nil
end
```

**ルール**:
- 外部データは必ずサニタイズ処理を通す
- 専用のサニタイズメソッドを作成して再利用する
- Strong Parameters的なアプローチで許可された属性のみ処理
- URLデータはプロトコル検証を行う

### 3. エラーハンドリングの改善

**指摘事項**: 一般的なエラーメッセージと例外クラス使用

**対応指針**:
```ruby
# ❌ 改善前
def get_config_value
  ENV["CONFIG_KEY"] || raise("Config not set")
end

# ✅ 改善後
def get_config_value
  ENV["CONFIG_KEY"] || raise(
    Rails::Configuration::ConfigurationError,
    "CONFIG_KEY environment variable is not set. " \
    "Please set CONFIG_KEY in your environment configuration " \
    "(e.g., in .env or your deployment environment) to enable the feature."
  )
end
```

**ルール**:
- Rails標準の例外クラスを使用（`Rails::Configuration::ConfigurationError`等）
- エラーメッセージには問題の説明と解決方法を含める
- 設定ファイルの場所やドキュメントへの参照を提供
- ログレベルを適切に設定（warn, error等）

## データ処理のベストプラクティス

### 1. 外部APIレスポンスの処理

```ruby
# Firebase、外部API等のレスポンス処理時
def process_external_data(response_data)
  # 1. データ存在チェック
  return nil if response_data.blank?
  
  # 2. 必要フィールドの存在確認
  required_fields = %w[id email name]
  return nil unless required_fields.all? { |field| response_data.key?(field) }
  
  # 3. サニタイズ処理
  sanitized_data = sanitize_response_data(response_data)
  
  # 4. バリデーション
  return nil unless valid_response_data?(sanitized_data)
  
  sanitized_data
end

private

def sanitize_response_data(data)
  {
    id: data["id"].to_s.strip,
    email: sanitize_email(data["email"]),
    name: sanitize_name(data["name"])
  }
end

def valid_response_data?(data)
  data[:email]&.match?(URI::MailTo::EMAIL_REGEXP) &&
  data[:name]&.present? &&
  data[:id]&.present?
end
```

### 2. バリデーション戦略

```ruby
class User < ApplicationRecord
  # 基本バリデーション
  validates :email, presence: true, 
                   format: { with: URI::MailTo::EMAIL_REGEXP },
                   uniqueness: { case_sensitive: false }
  
  # カスタムバリデーション
  validate :email_domain_allowed, if: :email_present?
  validate :firebase_uid_format, if: :firebase_uid_present?
  
  private
  
  def email_present?
    email.present?
  end
  
  def firebase_uid_present?
    firebase_uid.present?
  end
  
  def email_domain_allowed
    return unless email.present?
    
    allowed_domains = %w[gmail.com example.com]  # 設定ファイルから取得推奨
    domain = email.split('@').last&.downcase
    
    unless allowed_domains.include?(domain)
      errors.add(:email, "#{domain} domain is not allowed")
    end
  end
  
  def firebase_uid_format
    return unless firebase_uid.present?
    
    unless firebase_uid.match?(/\A[a-zA-Z0-9]{28}\z/)
      errors.add(:firebase_uid, "has invalid format")
    end
  end
end
```

## テスト実装での考慮事項

### 1. セキュリティテストの追加

```ruby
# バリデーションテスト
test "不正なメールアドレスを拒否すること" do
  user = User.new(firebase_uid: "valid_uid", email: "invalid-email", name: "Test")
  assert_not user.valid?
  assert_includes user.errors[:email], "is invalid"
end

# サニタイズテスト
test "外部データのサニタイズが正しく動作すること" do
  controller = create_test_controller
  payload = {
    "email" => "  TEST@EXAMPLE.COM  ",
    "name" => "  Test User  ",
    "picture" => "javascript:alert('xss')"  # 不正なURL
  }
  
  attributes = controller.send(:build_user_attributes_from_payload, payload)
  
  assert_equal "test@example.com", attributes[:email]
  assert_equal "Test User", attributes[:name]
  assert_nil attributes[:image_url]  # 不正URLは除外
end
```

### 2. エラーケースのテスト

```ruby
test "設定不備時の適切なエラーメッセージ" do
  ENV["FIREBASE_PROJECT_ID"] = nil
  
  error = assert_raises(Rails::Configuration::ConfigurationError) do
    @controller.send(:firebase_project_id)
  end
  
  assert_includes error.message, "FIREBASE_PROJECT_ID environment variable is not set"
  assert_includes error.message, "Please set FIREBASE_PROJECT_ID"
end
```

## チェックリスト

新しいコードを実装する際の確認項目：

### モデル実装時
- [ ] 必須フィールドに `presence: true` バリデーション
- [ ] 一意制約が必要なフィールドに `uniqueness: true`
- [ ] メールフィールドに適切な形式バリデーション
- [ ] カスタムバリデーションで業務ロジックを実装

### 外部データ処理時
- [ ] 外部データを直接モデルに渡していないか
- [ ] サニタイズ処理を実装しているか
- [ ] データ存在チェックを行っているか
- [ ] URLや特殊なデータ型の検証を行っているか

### エラーハンドリング実装時
- [ ] Rails標準の例外クラスを使用しているか
- [ ] エラーメッセージに解決方法を含めているか
- [ ] 適切なログレベルを設定しているか
- [ ] 本番環境での機密情報漏洩を防いでいるか

### テスト実装時
- [ ] バリデーションの成功・失敗ケース
- [ ] サニタイズ処理のテスト
- [ ] エラーケースのテスト
- [ ] セキュリティに関するテスト

このガイドラインに従うことで、セキュアで保守性の高いコードを継続的に生成できます。

